local function getNumber( presses, startPos )
	local noTemp
	local number = ""
	local keyAfter = ""

	local i = startPos
	temp = presses[i]
	while temp ~= nil do
		local tempNo = tonumber( temp )
		if tempNo ~= nil then
			number = number .. tempNo
		else
			keyAfter = temp
			break
		end
		i = i + 1
		temp = presses[i]
	end
	
	if number == "" then
		number = tonumber(1)
	else
		number = tonumber(number)
	end

	return number, i, keyAfter
end

local function parseViCommand( presses ) 
	local numbers = { tonumber(1), tonumber(1) }
	local otherMod

	local sPos = 1
	numbers[1], sPos, otherMod = getNumber( presses, sPos )
	numbers[2] = getNumber( presses, sPos + 1 )

	return otherMod, numbers[1], numbers[2]
end

local function cursorVerticalMove( numberMod )
		local curLine = global.getVar("currentLine") + numberMod

		-- Check how many lines are on the screen
		local linesOnScreen = 0
		local skippedLines = 0
		local i=global.getVar("topLine")
		while i <= global.getVar("topLine") + global.getVar("termY") - 2 - skippedLines do
			if i > global.getLength() then break end
			linesOnScreen = linesOnScreen + 1

			-- Please don't toture me to hard for this
			local ch = math.floor(string.len(global.getLine(i)) / (global.getVar("termX") + 0.000001))
			skippedLines = skippedLines + ch

			i = i + 1

		end

		--logger.info("skippedLines " .. skippedLines)
		--logger.info("linesOnScreen " .. linesOnScreen)

		while curLine < 1 do
			curLine = curLine + 1
		end
		while curLine > global.getLength() do
			curLine = curLine - 1
		end

		-- scroll topLine upwards/downwards until curLine is on the screen
		while curLine < global.getVar("topLine") do
			global.setVar("topLine", global.getVar("topLine") - 1)
		end
		while curLine > global.getVar("topLine") + linesOnScreen - 1 do
			global.setVar("topLine", global.getVar("topLine") + 1)
		end
		global.setVar("currentLine", curLine)

		-- Fix the column if it's to large
		if global.getVar("actualColumn") > global.getVar("currentColumn") then
			global.setVar("currentColumn", global.getVar("actualColumn"))
		end
		local curX = global.getVar("currentColumn")
		local strLen = string.len(global.getLine(curLine))
		if curX > strLen then
			curX = strLen
		end
		if strLen == 0 then
			curX = 1
		end
		global.setVar("currentColumn", curX)
end

local function move( command, numberMod, actionType, otherMod )
	-- command is how the cusor should move, among a few other things
	-- 		horiz
	-- 		vert
	-- 		delEol - delete end of line 'J'
	--
	--	These can be called with the following keys:
	-- 		h, j, k, l
	-- 		0, ^, $
	-- 		w, W, e, E, b, B
	-- 		f, F, t, T
	-- 		(, ), {, }, [[, ]], []
	-- numberMod is how many time the move command should be repeated
	-- otherMod if anything should be done while moving the cursor
	-- 		y, Y
	-- 		d, D
	-- 		c, C
	-- 		x, X
	-- 		~
	--
	-- Please notice that all of these commands can't stack
	--
	-- Almost no commands wrap around lines
	--
	-- All commands take a numberMod and a move command unless
	-- otherwise stated.
	--
	--
	--
	-- M O V E S
	-- h, move left
	-- l, move right
	-- j, mode down
	-- k, move up
	--
	-- ^, move left until start of text
	-- 0, move left until start of line
	-- $, move right until end of line
	--
	-- w, move right until start of next word
	-- W, move right until after next space
	-- e, move right until end of current word
	-- E, move right up to the next space 
	-- b, move left to start of current word
	-- B, move left until preceeding space
	--
	--	All these takes one extra argument, to know what to find
	-- f, move left until cursor is on a selected character
	-- F, move right until cursor is on a selected character
	-- t, move left until cunros is on the character before the selected character
	-- T, move right until cunros is on the character before the selected character
	--
	-- (, ), ... 	These have to do with jumping sections, 
	-- 	but otherwise they work as normal move commands
	--
	-- O T H E R _ M O D
	-- 	Some of these have special cases where their function can differ on things
	-- 	not related to move commands. (dd deletes the current line, for example)
	--
	-- y, copy characters moved over
	-- Y, copy current line, doesn't take move commands
	-- d, cut charactors moved over
	-- D, cut from current column until end of line, doesn't take move commands
	-- c, like 'd', but enters insert mode afterwards
	-- D, lide 'D', but enters insert mode afterwards 
	--
	-- x, delete 'numberMod' characters forwards. Doesn't take move commands
	-- X, delete 'numberMod' characters backwards. Doesn't take move commands
	-- ~, change case for upcomming 'numberMod' characters. Doesn't take move commands


	-- merges current line with the next line, removes that line ('J')
	if command == "delEol" then
		local nextLine = global.getVar("currentLine") + 1
		local mSpace
		if otherMod == "space" then mSpace = " " else mSpace = "" end
		if global.getLine(nextLine) ~= nil then
			global.setCurLine( 
				global.getCurLine() .. 
				mSpace ..
				global.getLine( nextLine ))
			global.removeLine( nextLine )
		end

	elseif command == "horiz" then
		if actionType == "delete" or actionType == "yank" then
			local curX = global.getVar("currentColumn")

			if actionType == "delete" then
				temp = global.getCurLine()
				if numberMod < 0 then
					temp = string.reverse( temp )
					-- TODO cases in the far edge of the string
					curX = string.len( temp ) - curX + 2
				end

				local goal = curX + math.abs(numberMod)

				local outString = 
					string.sub( temp, 0, curX - 1 ) ..
					string.sub( temp, goal )

				if numberMod < 0 then
					outString = string.reverse( outString )
					move( "horiz", numberMod, "move", "n" )
				end
				global.setCurLine( outString )

				if otherMod == "i" then
					vimode.insertMode("here")
				end
			 end

		else -- simple move
			local xBefore = global.getVar("currentColumn")
			local xAfter = xBefore + numberMod
			if xAfter < 1 then xAfter = 1 end
			if xAfter > string.len(global.getCurLine()) then
				xAfter = string.len(global.getCurLine()) end
			global.setVar("currentColumn", xAfter)
			global.setVar("actualColumn" , xAfter)
		end
		
	elseif command == "vert" then
		if actionType == "delete" or actionType == "yank" then
			--TODO (Why, why do i know...) these thing

		else
			cursorVerticalMove( numberMod )
		end
	end
	screen.redraw()
end

local function goToEndOfLine( actionType )
	move( 
		"horiz", 
		  string.len(global.getCurLine()) - global.getVar("currentColumn") + 1,
		  actionType, "n")
end

local function goToStart( actionType, location )
	-- location can be ( line | text )
	local wsS, wsE = 
		string.find( global.getCurLine(), "%s+" )
	if location == "text" then
		if wsS ~= 1 then wsE = 0 end
	else 
		wsE = 0 
	end
	move( "horiz",
		  -(global.getVar("currentColumn") - (wsE + 1)),
		  use, subMod)
end

-- command should be a 'char' array
--
-- returns if the command triggered something
function runViCommand( command )
	-- This is so that a command is't otherMod of itself
	local commandSub = {}
	for i=1, #command - 1 do
		commandSub[i] = command[i]
	end
	local otherMod, number1, number2 = parseViCommand( commandSub );

	logger.info(" n1: " .. number1)
	logger.info(" n2: " .. number2) -- n2 isn't used...
	logger.info("--------" .. os.time())

	-- set this back to false if something shouldn't trigger
	-- but most things should trigger, thereby true by default
	local triggered = true

	local use = "move" -- default value
	local subMod = "n"
	if otherMod == "d" then
		use = "delete"
	elseif otherMod == "c" then
		use = "delete"
		subMod = "i"
	elseif otherMod == "y" then
		use = "yank"
	elseif otherMod == "" then
		use = "move"
	end

	for number1Loop=1, number1 do
		if command[#command] == "f" or 
		   command[#command] == "t" then
		   local event, keyToFind = os.pullEvent("char")

		   for i=1, number2 do
				local tempX = string.find(global.getLine(
					global.getVar("currentLine")), keyToFind, global.getVar("currentColumn") + 1)
				if tempX ~= nil then
					global.setVar("currentColumn", tempX)
				end
			end
			if command[#command] == "t" then
				global.setVar("currentColumn", global.getVar("currentColumn") - 1)
			end
				
		elseif command[#command] == "l" then
			move( "horiz", number2, use, subMod )
				
		elseif command[#command] == "h" then
			move( "horiz", -number2, use, subMod )
				
		elseif command[#command] == "j" then
			move( "vert", number2, use, subMod )

		elseif command[#command] == "k" then
			move( "vert", -number2, use, subMod )

		elseif command[#command] == "$" then
			goToEndOfLine( "move" )

		elseif command[#command] == "^" then
			goToStart( use, "text" )

		elseif command[#command] == "0" and
		       tonumber(command[#command - 1]) == nil then
			goToStart( use, "line" )


		elseif command[#command] == "w" or command[#command] == "W" then
			for i=1, number2 do
				local tXS =
					string.find(global.getCurLine(), "%s", global.getVar("currentColumn"))
					or string.len(global.getCurLine())
				tXS = tXS - global.getVar("currentColumn") + 1
				move( "horiz", tXS, use, otherMod )
			end
		
		-- 'de' delets one character to little
		elseif command[#command] == "e" or command[#command] == "E" then
			for i=1, number2 do
				local tXS =
					string.find(global.getCurLine(), "%s", global.getVar("currentColumn") + 2)
					or string.len(global.getCurLine())
				tXS = tXS - global.getVar("currentColumn") - 1
				move( "horiz", tXS, use, otherMod )
			end

		-- this maybe should be written a bit more recursivly
		elseif command[#command] == "b" or command[#command] == "B" then
			for i=1, number2 do
				local tempLine = string.reverse(global.getCurLine())
				local tXS =
					string.find(tempLine, "%s", string.len(tempLine) - global.getVar("currentColumn") + 2)
					or string.len(tempLine)
				tXS = string.len(tempLine) - tXS - global.getVar("currentColumn") + 2
				if tXS == 0 then
					move( "horiz", -1, use, "n" )
					tXS =
						string.find(tempLine, "%s", string.len(tempLine) - global.getVar("currentColumn") + 2)
						or string.len(tempLine)
					tXS = string.len(tempLine) - tXS - global.getVar("currentColumn") + 2
				end
				move( "horiz", tXS, use, otherMod )
			end
		


		elseif command[#command] == "x" then
			move( "horiz", number2, "delete", subMod )
		elseif command[#command] == "X" then
			move( "horiz", -number2, "delete", subMod )
		


		elseif command[#command] == "J" then
			move( "delEol", number2, "delEol", "space" )

		elseif command[#command] == "d" then
			if otherMod == "d" then
				for i=1, number2 do
					goToStart( "move", "line" )
					goToEndOfLine( "delete" )
					move( "delEol", 1, "delEol", "noSpace" )
				end
			else
				triggered = false
			end

		elseif command[#command] == "D" then
			local lLoop = number1 * number2
			number1 = 1
			for i=2, lLoop do
				move( "delEol", 1, "delEol", "noSpace" )
			end
			goToEndOfLine( "delete" )

		elseif command[#command] == "C" then
			local lLoop = number1 * number2
			number1 = 1
			for i=2, lLoop do
				move( "delEol", 1, "delEol", "noSpace" )
			end
			goToEndOfLine( "delete" )
			vimode.insertMode("here")


		elseif command[#command] == "i" then
			vimode.insertMode("here")
		
		elseif command[#command] == "I" then
			if command[1] == "g" then
				vimode.insertMode("0")
			else
				vimode.insertMode("beginning")
			end
		
		elseif command[#command] == "a" then
			vimode.insertMode("after")
		
		elseif command[#command] == "A" then
			vimode.insertMode("end")

		elseif command[#command] == "o" then
			vimode.insertMode("newline")

		elseif command[#command] == "O" then
			vimode.insertMode("prevline")

		

		else
			-- if nothing happened then triggered sholud be false
			-- this is so I don't have to specify triggered=true on
			-- for every possible command
			triggered = false
		end
	end


	screen.redraw()
	return triggered
end

local function parseExCommand( text ) 
	local len = string.len(text)
	local value = {}
	for i=1, #text do
		value[i] = text:sub(i, i)
	end
	return value
end

function runExCommand( command )
	local cmd = parseExCommand( command )

	local fun = {}

	function fun.q()
		if global.getVar("hasChanged") then
			screen.printErrMsg("No write since last change, ! to override")
		else
			global.setVar("running", false)
		end
	end
	function fun.b()
		global.setVar("running", false)
	end
	function fun.w()
		file.write()
	end

	for i=1, #cmd do
		screen.printErrMsg(cmd[i])
		fun[cmd[i]]()
	end
end
