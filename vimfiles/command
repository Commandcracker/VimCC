local function parseViCommand( presses ) 
	local numberMod = tonumber(1)
	local otherMod = {}

	local numbers = ""

	for i=1, #presses do
		local temp = tonumber( presses[i] )
		if temp ~= nil then
			numbers = numbers .. temp
		end
	end

	if numbers ~= "" then
		numberMod = tonumber(numbers)
	end


	return numberMod, otherMod


end

-- used by the 'j' and 'k' move commands
local function cursorVerticalMove( numberMod )
		local curLine = global.getVar("currentLine") + numberMod

		-- Check how many lines are on the screen
		local linesOnScreen = 0
		local skippedLines = 0
		local i=global.getVar("topLine")
		while i <= global.getVar("topLine") + global.getVar("termY") - 2 - skippedLines do
			if i > global.getLength() then break end
			linesOnScreen = linesOnScreen + 1

			-- Please don't toture me to hard for this
			local ch = math.floor(string.len(global.getLine(i)) / (global.getVar("termX") + 0.000001))
			skippedLines = skippedLines + ch

			i = i + 1

		end

		--logger.info("skippedLines " .. skippedLines)
		--logger.info("linesOnScreen " .. linesOnScreen)

		while curLine < 1 do
			curLine = curLine + 1
		end
		while curLine > global.getLength() do
			curLine = curLine - 1
		end

		-- scroll topLine upwards/downwards until curLine is on the screen
		while curLine < global.getVar("topLine") do
			global.setVar("topLine", global.getVar("topLine") - 1)
		end
		while curLine > global.getVar("topLine") + linesOnScreen - 1 do
			global.setVar("topLine", global.getVar("topLine") + 1)
		end
		global.setVar("currentLine", curLine)

		-- Fix the column if it's to large
		if global.getVar("actualColumn") > global.getVar("currentColumn") then
			global.setVar("currentColumn", global.getVar("actualColumn"))
		end
		local curX = global.getVar("currentColumn")
		local strLen = string.len(global.getLine(curLine))
		if curX > strLen then
			curX = strLen
		end
		if strLen == 0 then
			curX = 1
		end
		global.setVar("currentColumn", curX)
end

-- command should be a 'char' array
--
-- returns if the command triggered something
-- 
-- This could be optimized by placing the commands in the order
-- most often used. Please don't do this
function runViCommand(command)
	local numberMod, otherMod = parseViCommand( command )

	-- set this back to false if something shouldn't trigger
	-- but most things should trigger, thereby true by default
	local triggered = true

	if command[#command] == "f" or 
	   command[#command] == "t" then
	   local event, keyToFind = os.pullEvent("char")

	   for i=1, numberMod do
			local tempX = string.find(global.getLine(
				global.getVar("currentLine")), keyToFind, global.getVar("currentColumn") + 1)
			if tempX ~= nil then
				global.setVar("currentColumn", tempX)
			end
		end
		if command[#command] == "t" then
			global.setVar("currentColumn", global.getVar("currentColumn") - 1)
		end
			
	elseif command[#command] == "l" then
		local curX = global.getVar("currentColumn") + numberMod
		local strLen = string.len(global.getCurLine())
		if curX > strLen then
			curX = strLen
		end
		if strLen == 0 then
			curX = 1
		end
		global.setVar("actualColumn", curX)
		global.setVar("currentColumn", curX)
			
	elseif command[#command] == "h" then
		local curX = global.getVar("currentColumn") - numberMod
		if curX < 1 then
			curX = 1
		end
		global.setVar("actualColumn", curX)
		global.setVar("currentColumn", curX)
			
	elseif command[#command] == "j" then
		if not (global.getVar("currentLine") == global.getLength()) then
			cursorVerticalMove(numberMod)
		end


	
	elseif command[#command] == "k" then
		if not (global.getVar("currentLine") == 1) then
			cursorVerticalMove( -numberMod )
		end

	elseif command[#command] == "$" then
		global.setVar("actualColumn", string.len(global.getCurLine()))
		global.setVar("currentColumn", string.len(global.getCurLine()))

	elseif command[#command] == "^" then
		global.setVar("actualColumn", 1)
		global.setVar("currentColumn", 1)

	
	elseif command[#command] == "w" or command[#command] == "W" then
		-- TODO differentiate between 'w' and "w"
		--
		-- This won't carry on to the next line, but it does work with linewrap
		for i=1, numberMod do
			local tXS, tXE = string.find(global.getCurLine(), "%s", global.getVar("currentColumn"))
			if  tXS ~= nil then
				global.setVar("currentColumn", tXS + 1)
			else
				global.setVar("currentColumn", string.len(global.getCurLine()))
			end
		end
	
	elseif command[#command] == "e" or command[#command] == "E" then
		for i=1, numberMod do
			local tXS, tXE = string.find(global.getCurLine(), "%s", global.getVar("currentColumn") + 2)
			if  tXS ~= nil then
				global.setVar("currentColumn", tXS - 1)
			else
				global.setVar("currentColumn", string.len(global.getCurLine()))
			end
		end
	
	-- TODO this is currently compleatly broken
	--[[
	elseif command[#command] == "b" or command[#command] == "B" then
		local tempX
		local line = global.getCurLine()
		local tXS, tXE = string.find( string.reverse(line), "%s", 
			string.len(line) - cursorX - 1)
			-- Aga|Thi wor -- 11
			-- orw ihT|agA
		if  tXS ~= nil then
			cursorX = string.len(line) - tXS + 2
		else
			cursorX = 1
		end
	]]



	
	elseif command[#command] == "x" then
		global.setVar("hasChanged", true)
		temp = global.getCurLine()
		a = string.sub(temp, 1, global.getVar("currentColumn") - 1)
		b = string.sub(temp, global.getVar("currentColumn") + numberMod, string.len(temp)) 
		global.setLine(global.getVar("currentLine"), a..b)
		
	

	elseif command[#command] == "i" then
		vimode.insertMode("here")
	
	elseif command[#command] == "I" then
		if command[1] == "g" then
			vimode.insertMode("0")
		else
			vimode.insertMode("beginning")
		end
	
	elseif command[#command] == "a" then
		vimode.insertMode("after")
	
	elseif command[#command] == "A" then
		vimode.insertMode("end")

	elseif command[#command] == "o" then
		vimode.insertMode("newline")

	elseif command[#command] == "O" then
		vimode.insertMode("prevline")



	
	elseif command[#command] == "d" then
		-- used to check if this is the secound 'd'
		local continue = false
		for i=1, #command - 1 do
			if command[i] == "d" then
				continue = true
			end
		end
		if continue then
			global.setVar("hasChanged", true)
			for i=0, numberMod - 1 do
				global.removeLine(global.getVar("currentLine"))
			end

		else
			triggered = false;
		end


	
	elseif command[#command] == ":" then
		local command = vimode.commandMode()
		runExCommand( command )


	else
		-- if nothing happened then triggered sholud be false
		-- this is so I don't have to specify triggered=true on
		-- for every possible command
		triggered = false
	end


	screen.redraw()
	return triggered
end

function parseExCommand( text ) 
end

function runExCommand( command )
	if command == "q" then
		if global.getVar("hasChanged") then
			term.setCursorPos(1, global.getVar("termY"))
			term.setBackgroundColour( colors.red )
			term.write("No write since last change, ! to override")
			term.setBackgroundColour( colors.black )
		else
			global.setVar("running", false)
		end
	end
	if command == "q!" then
		global.setVar("running", false)
	end
	if command == "w" then
		file.write()
	end
	if command == "wq" then
		file.write()
		global.setVar("running", false)
	end
end
