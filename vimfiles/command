
local function parseViCommand( presses ) 
	local numberMod = tonumber(1)
	local otherMod = {}

	local numbers = ""

	for i=1, #presses do
		local temp = tonumber( presses[i] )
		if temp ~= nil then
			numbers = numbers .. temp
		end
	end

	if numbers ~= "" then
		numberMod = tonumber(numbers)
	end


	return numberMod, otherMod

end

-- command should be a 'char' array
--
-- returns if the command triggered something
function runViCommand( command, cursorX, cursorY )
	local numberMod, otherMod = parseViCommand( command )

	local triggered = true

	if command[#command] == "f" or 
	   command[#command] == "t" then
	   local event, keyToFind = os.pullEvent("char")

	   for i=1, numberMod do
			local tempX = string.find(global.getLine(
				global.getVar("currentLine")), keyToFind, cursorX + 1)
			if tempX ~= nil then
				cursorX = tempX
			end
		end
		if command[#command] == "t" then
			cursorX = cursorX - 1
		end
	
	elseif command[#command] == "l" then
		--cursorX = cursorX + numberMod
		global.setVar("currentColumn", global.getVar("currentColumn") + numberMod)
		screen.redraw()
	
	elseif command[#command] == "h" then
		--cursorX = cursorX - numberMod
		global.setVar("currentColumn", global.getVar("currentColumn") - numberMod)
		screen.redraw()
	
	elseif command[#command] == "j" then
		if not (global.getVar("currentLine") == global.getLength()) then
			local curLine = global.getVar("currentLine") + numberMod

			local linesOnScreen = 0
			local skippedLines = 0

			-- Loop through all the lines on the screen
			local i=global.getVar("topLine")
			cursorY = 1
			while i <= global.getVar("topLine") + global.getVar("termY") - 2 - skippedLines do
				if i > global.getLength() then break end
				linesOnScreen = linesOnScreen + 1
				-- Please don't toture me to hard for this
				local ch = (math.floor(string.len(global.getLine(i)) / (global.getVar("termX") + 0.000001)))
				skippedLines = skippedLines + ch

				-- Brute forcing the cursor position
				--[[
				if i < curLine then
					cursorY = cursorY + 1 + ch
				end
				]]
				i = i + 1

			end

			--logger.log("skippedLines " .. skippedLines)
			--logger.log("linesOnScreen " .. linesOnScreen)

			while curLine > global.getLength() do
				curLine = curLine - 1
			end

			-- scroll topLine downwards until curLine is on the screen
			while curLine > global.getVar("topLine") + linesOnScreen - 1 do
				global.setVar("topLine", global.getVar("topLine") + 1)
				--cursorY = cursorY - 1
			end
			global.setVar("currentLine", curLine)

			screen.redraw()
		end


	
	elseif command[#command] == "k" then
		if not (global.getVar("currentLine") == 1) then
			local curLine = global.getVar("currentLine") - numberMod

			local linesOnScreen = 0
			local skippedLines = 0

			-- Loop through all the lines on the screen
			local i=global.getVar("topLine")
			cursorY = 1
			while i <= global.getVar("topLine") + global.getVar("termY") - 2 - skippedLines do
				linesOnScreen = linesOnScreen + 1
				-- Please don't toture me to hard for this
				logger.log(i)
				local ch = (math.floor(string.len(global.getLine(i)) / (global.getVar("termX") + 0.000001)))
				skippedLines = skippedLines + ch

				-- Brute forcing the cursor position
				--[[
				if i < curLine then
					cursorY = cursorY + 1 + ch
				end
				]]
				i = i + 1

			end

			--logger.log("skippedLines " .. skippedLines)
			--logger.log("linesOnScreen " .. linesOnScreen)

			while curLine < 1 do
				curLine = curLine + 1
			end

			-- scroll topLine upwards until curLine is on the screen
			while curLine < global.getVar("topLine") do
				global.setVar("topLine", global.getVar("topLine") - 1)
			end
			global.setVar("currentLine", curLine)

			screen.redraw()
		end

	
	elseif command[#command] == "w" or command[#command] == "W" then
		-- TODO differentiate between 'w' and "w"
		--
		-- This won't work then the line wrap
		-- TODO change to use "currentColumn"
		for i=1, numberMod do
			local tXS, tXE = string.find(global.getLine(global.getVar("currentLine")), "%s", cursorX)
			if  tXS ~= nil then
				cursorX = tXS + 1
			else
				cursorX = string.len(global.getLine(global.getVar("currentLine")))
			end
		end
	
	elseif command[#command] == "e" or command[#command] == "E" then
		for i=1, numberMod do
			local tXS, tXE = string.find(global.getLine(global.getVar("currentLine")), "%s", cursorX + 2)
			if  tXS ~= nil then
				cursorX = tXS - 1
			else
				cursorX = string.len(global.getLine(global.getVar("currentLine")))
			end
		end
	
	elseif command[#command] == "b" or command[#command] == "B" then
		local tempX
		local line = global.getLine(global.getVar("currentLine"))
		local tXS, tXE = string.find( string.reverse(line), "%s", 
			string.len(line) - cursorX - 1)
			-- Aga|Thi wor -- 11
			-- orw ihT|agA
		if  tXS ~= nil then
			cursorX = string.len(line) - tXS + 2
		else
			cursorX = 1
		end



	
	elseif command[#command] == "x" then
		global.setVar("hasChanged", true)
		temp = global.getLine(global.getVar("currentLine"))
		a = string.sub(temp, 1, cursorX - 1)
		b = string.sub(temp, cursorX + numberMod, string.len(temp)) 
		global.setLine(global.getVar("currentLine"), a..b)
		screen.redraw()

	
	elseif command[#command] == "i" then
		cursorX, cursorY = vimode.insertMode(global.getVar("currentLine"), cursorX, "here")
	
	elseif command[#command] == "I" then
		if command[1] == "g" then
			cursorX, cursorY = vimode.insertMode(global.getVar("currentLine"), cursorX, "0")
		else
			cursorX, cursorY = vimode.insertMode(global.getVar("currentLine"), cursorX, "beginning")
		end
	
	elseif command[#command] == "a" then
		cursorX, cursorY = vimode.insertMode(global.getVar("currentLine"), cursorX, "after")
	
	elseif command[#command] == "A" then
		cursorX, cursorY = vimode.insertMode(global.getVar("currentLine"), cursorX, "end")

	elseif command[#command] == "o" then
		cursorX, cursorY = vimode.insertMode(global.getVar("currentLine"), cursorX, "newline")

	elseif command[#command] == "O" then
		cursorX, cursorY = vimode.insertMode(global.getVar("currentLine"), cursorX, "prevline")



	
	elseif command[#command] == "d" then
		-- used to check if this is the secound 'd'
		local continue = false
		for i=1, #command - 1 do
			if command[i] == "d" then
				continue = true
			end
		end
		if continue then
			global.setVar("hasChanged", true)
			for i=0, numberMod - 1 do
				global.removeLine(global.getVar("currentLine"))
			end

			screen.redraw()
		else
			triggered = false;
		end


	
	elseif command[#command] == ":" then
		local command = vimode.commandMode()
		runExCommand( command )


	else
		triggered = false
	end


	return triggered, cursorX, cursorY
end

function parseExCommand( text ) 
end

function runExCommand( command )
	if command == "q" then
		if global.getVar("hasChanged") then
			term.setCursorPos(1, global.getVar("termY"))
			term.setBackgroundColour( colors.red )
			term.write("No write since last change, ! to override")
			term.setBackgroundColour( colors.black )
		else
			global.setVar("running", false)
		end
	end
	if command == "q!" then
		global.setVar("running", false)
	end
	if command == "w" then
		file.write()
	end
	if command == "wq" then
		file.write()
		global.setVar("running", false)
	end
end
